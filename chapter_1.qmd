---
title: "Queries with Dates"
filters:
  - interactive-sql
databases:
  - name: subscribers
    path: "https://raw.githubusercontent.com/Alaburda/data-analyst-sql-cookbook/master/db/subscribers.db"

---

# Intersecting Dates

Let's say you have a table of subscription that all different start and end dates. How would you filter down a list of subscriptions to show those that were active within a time range? In other words, how do you find rows that have intersecting dates?

For example, here are all subscribers that had active subscriptions in 2023:

```{.sql .interactive .subscribers}

select *
from subscribers
where date_from <= '2023-12-31'
and date_to >= '2023-01-01'

```

# Calculating date ranges based on gaps

Let's say we have subscriptions but we need to show a start date and an end date of gaps between subscriptions. For example, if I subscribed from 2023-01-01 to 2023-05-31 and then from 2023-07-01 to 2023-12-31, I would want to return a row that said I was not a subscriber from 2023-06-01 to 2023-06-30.

```{.sql .interactive .chinook}
SELECT   
  seqval + 1 AS start_range,   
  (
    SELECT 
      MIN(B.seqval)    
    FROM dbo.NumSeq AS B    
    WHERE B.seqval > A.seqval
    ) - 1 AS end_range 
FROM dbo.NumSeq AS A 
WHERE NOT EXISTS (
  SELECT * FROM dbo.NumSeq AS B    
  WHERE B.seqval = A.seqval + 1)
AND seqval < (SELECT MAX(seqval) FROM dbo.NumSeq);

```

This solution is based on subqueries. In order to understand it you should first focus on the filtering activity in the WHERE clause and then proceed to the activity in the SELECT list. The purpose of the NOT EXISTS predicate in the WHERE clause is to filter only points that are a point before a gap. You can identify a point before a gap when you see that for such a point, the value plus 1 doesnâ€™t exist in the sequence. The purpose of the second predicate in the WHERE clause is to filter out the maximum value from the sequence because it represents the point before infinity, which does not concern us.

# Sessionization

# Islands Problem

```{.sql .interactive .chinook}

SELECT 
  MIN(seqval) AS start_range, 
  MAX(seqval) AS end_range 
FROM (
  SELECT 
    seqval, 
    seqval - ROW_NUMBER() OVER (ORDER BY seqval) AS grp
  FROM dbo.NumSeq
  ) AS D GROUP BY grp;

```

# 
