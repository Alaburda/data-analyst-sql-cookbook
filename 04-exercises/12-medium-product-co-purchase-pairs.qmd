---
title: "[Medium] Product Co-Purchase Pairs"
filters:
  - interactive-duckdb
databases:
  - name: cookbook
    path: "https://raw.githubusercontent.com/Alaburda/data-analyst-sql-cookbook/master/db/cookbook.duckdb"
    format: duckdb
---

# Problem Statement

Find product pairs that are frequently bought together in the same order. This is a market basket analysis pattern useful for product recommendations and cross-selling.

**Skills tested:** Self-join, Aggregation, Avoiding duplicate pairs, Filtering

## Schema

### order_items
```
order_item_id  INTEGER
order_id       INTEGER
product_id     INTEGER
quantity       INTEGER
line_total     DECIMAL
```

### products
```
product_id     INTEGER
product_name   VARCHAR
category       VARCHAR
unit_price     DECIMAL
```

## Sample Data

```{.sql .interactive .cookbook}
-- View orders with multiple items
SELECT 
    oi.order_id,
    COUNT(*) AS item_count,
    STRING_AGG(p.product_name, ', ') AS products
FROM order_items oi
JOIN products p ON oi.product_id = p.product_id
GROUP BY oi.order_id
HAVING COUNT(*) >= 2
ORDER BY item_count DESC
LIMIT 10;
```

## Expected Output

| product_a          | product_b          | times_bought_together | support_pct |
|-------------------|-------------------|----------------------|-------------|
| Laptop Pro        | Wireless Mouse    | 45                   | 15.2%       |
| Laptop Pro        | Laptop Bag        | 38                   | 12.8%       |
| Coffee Maker      | Coffee Beans      | 32                   | 10.8%       |
| ...               | ...               | ...                  | ...         |

## Requirements

1. Find all product pairs that appear in the same order
2. Count how many times each pair appears together
3. Avoid duplicate pairs (A+B is same as B+A)
4. Ensure A and B are different products
5. Calculate support percentage (% of orders containing the pair)
6. Order by frequency descending

## Hints

<details>
<summary>Click to reveal hint 1</summary>

Use a self-join on `order_items` to find products in the same order:
```sql
FROM order_items oi1
JOIN order_items oi2 ON oi1.order_id = oi2.order_id
```

</details>

<details>
<summary>Click to reveal hint 2</summary>

Avoid counting the same pair twice and prevent self-pairs:
```sql
WHERE oi1.product_id < oi2.product_id
```

This ensures product_a always has a smaller ID than product_b.

</details>

<details>
<summary>Click to reveal hint 3</summary>

Calculate support percentage:
```sql
ROUND(100.0 * COUNT(DISTINCT oi1.order_id) / (SELECT COUNT(DISTINCT order_id) FROM orders), 2)
```

</details>

## Solution Template

```{.sql .interactive .cookbook}
WITH product_pairs AS (
    SELECT 
        oi1.product_id AS product_a_id,
        oi2.product_id AS product_b_id,
        oi1.order_id
    FROM order_items oi1
    JOIN order_items oi2 
        ON oi1.order_id = oi2.order_id
        -- Prevent self-pairs and duplicates
    WHERE oi1.product_id < oi2.product_id
)
SELECT 
    p1.product_name AS product_a,
    p2.product_name AS product_b,
    -- Count co-occurrences
    -- Calculate support percentage
FROM product_pairs pp
JOIN products p1 ON pp.product_a_id = p1.product_id
JOIN products p2 ON pp.product_b_id = p2.product_id
GROUP BY p1.product_name, p2.product_name
ORDER BY times_bought_together DESC
LIMIT 20;
```

## Solution

<details>
<summary>Click to reveal solution</summary>

```{.sql .interactive .cookbook}
WITH product_pairs AS (
    SELECT 
        oi1.product_id AS product_a_id,
        oi2.product_id AS product_b_id,
        oi1.order_id
    FROM order_items oi1
    JOIN order_items oi2 
        ON oi1.order_id = oi2.order_id
        AND oi1.product_id < oi2.product_id
),
pair_counts AS (
    SELECT 
        product_a_id,
        product_b_id,
        COUNT(DISTINCT order_id) AS times_bought_together
    FROM product_pairs
    GROUP BY product_a_id, product_b_id
),
total_orders AS (
    SELECT COUNT(DISTINCT order_id) AS total FROM orders
)
SELECT 
    p1.product_name AS product_a,
    p2.product_name AS product_b,
    pc.times_bought_together,
    ROUND(100.0 * pc.times_bought_together / t.total, 2) AS support_pct
FROM pair_counts pc
JOIN products p1 ON pc.product_a_id = p1.product_id
JOIN products p2 ON pc.product_b_id = p2.product_id
CROSS JOIN total_orders t
WHERE pc.times_bought_together >= 3  -- At least 3 occurrences
ORDER BY pc.times_bought_together DESC
LIMIT 20;
```

</details>

## With Confidence and Lift

<details>
<summary>Click to reveal advanced metrics (confidence, lift)</summary>

```{.sql .interactive .cookbook}
WITH product_pairs AS (
    SELECT 
        oi1.product_id AS product_a_id,
        oi2.product_id AS product_b_id,
        oi1.order_id
    FROM order_items oi1
    JOIN order_items oi2 
        ON oi1.order_id = oi2.order_id
        AND oi1.product_id < oi2.product_id
),
pair_counts AS (
    SELECT 
        product_a_id,
        product_b_id,
        COUNT(DISTINCT order_id) AS ab_count
    FROM product_pairs
    GROUP BY product_a_id, product_b_id
),
product_counts AS (
    SELECT 
        product_id,
        COUNT(DISTINCT order_id) AS product_count
    FROM order_items
    GROUP BY product_id
),
total_orders AS (
    SELECT COUNT(DISTINCT order_id) AS total FROM orders
)
SELECT 
    p1.product_name AS product_a,
    p2.product_name AS product_b,
    pc.ab_count AS times_together,
    ROUND(100.0 * pc.ab_count / t.total, 2) AS support_pct,
    ROUND(100.0 * pc.ab_count / pca.product_count, 2) AS confidence_a_to_b,
    ROUND(100.0 * pc.ab_count / pcb.product_count, 2) AS confidence_b_to_a,
    ROUND(
        (pc.ab_count * t.total * 1.0) / 
        (pca.product_count * pcb.product_count), 2
    ) AS lift
FROM pair_counts pc
JOIN products p1 ON pc.product_a_id = p1.product_id
JOIN products p2 ON pc.product_b_id = p2.product_id
JOIN product_counts pca ON pc.product_a_id = pca.product_id
JOIN product_counts pcb ON pc.product_b_id = pcb.product_id
CROSS JOIN total_orders t
WHERE pc.ab_count >= 3
ORDER BY lift DESC
LIMIT 20;
```

**Metrics explained:**
- **Support:** How often the pair appears (% of all orders)
- **Confidence:** P(B|A) - If A is bought, probability of B being bought
- **Lift:** How much more likely B is bought when A is bought (vs random)
  - Lift > 1: Positive correlation
  - Lift = 1: No correlation
  - Lift < 1: Negative correlation

</details>

## Category-Level Analysis

<details>
<summary>Click to reveal category co-purchase analysis</summary>

```{.sql .interactive .cookbook}
WITH category_pairs AS (
    SELECT 
        p1.category AS category_a,
        p2.category AS category_b,
        oi1.order_id
    FROM order_items oi1
    JOIN order_items oi2 ON oi1.order_id = oi2.order_id
    JOIN products p1 ON oi1.product_id = p1.product_id
    JOIN products p2 ON oi2.product_id = p2.product_id
    WHERE p1.category < p2.category
)
SELECT 
    category_a,
    category_b,
    COUNT(DISTINCT order_id) AS times_together,
    ROUND(100.0 * COUNT(DISTINCT order_id) / (SELECT COUNT(DISTINCT order_id) FROM orders), 2) AS support_pct
FROM category_pairs
GROUP BY category_a, category_b
ORDER BY times_together DESC;
```

</details>

## For Specific Product

<details>
<summary>Click to reveal recommendations for a specific product</summary>

```{.sql .interactive .cookbook}
-- What products are commonly bought with "Premium Laptop"?
WITH target_product AS (
    SELECT product_id 
    FROM products 
    WHERE product_name = 'Premium Laptop'
    LIMIT 1
),
product_pairs AS (
    SELECT 
        oi2.product_id AS recommended_product_id,
        oi1.order_id
    FROM order_items oi1
    JOIN order_items oi2 
        ON oi1.order_id = oi2.order_id
        AND oi1.product_id != oi2.product_id
    WHERE oi1.product_id = (SELECT product_id FROM target_product)
)
SELECT 
    p.product_name AS recommended_product,
    p.category,
    COUNT(DISTINCT pp.order_id) AS times_bought_together,
    ROUND(100.0 * COUNT(DISTINCT pp.order_id) / 
          (SELECT COUNT(DISTINCT order_id) FROM order_items WHERE product_id = (SELECT product_id FROM target_product)), 
          1) AS confidence_pct
FROM product_pairs pp
JOIN products p ON pp.recommended_product_id = p.product_id
GROUP BY p.product_name, p.category
ORDER BY times_bought_together DESC
LIMIT 10;
```

</details>

## Extensions

1. **Temporal patterns:** Find pairs bought together in specific seasons/months
2. **Customer segments:** Analyze co-purchase patterns by customer segment
3. **Bundle recommendations:** Find the best 3-item bundles
4. **Sequence analysis:** Products bought in sequence across multiple orders
5. **Negative associations:** Find products rarely bought together (substitutes)
6. **Revenue lift:** Calculate revenue impact of bundling recommendations
